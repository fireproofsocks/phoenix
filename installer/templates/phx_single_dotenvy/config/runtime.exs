import Config
import Dotenvy

# For local development, read dotenv files inside the envs/ dir;
# for releases, read them at the RELEASE_ROOT
env_dir_prefix = System.get_env("RELEASE_ROOT") || Path.expand("./envs/") <> "/"

source!([
  "#{env_dir_prefix}.env",
  "#{env_dir_prefix}.#{config_env()}.env",
  "#{env_dir_prefix}.#{config_env()}.overrides.env",
  System.get_env()
])

# config/runtime.exs is executed for all environments, including
# during releases. It is executed after compilation and before the
# system starts Do not define any compile-time configuration in here,
# as it won't be applied.

# ## Using releases
#
# If you use `mix release`, you need to explicitly enable the server
# by passing the PHX_SERVER=true when you start it:
#
#     PHX_SERVER=true bin/src_me start
#
# Alternatively, you can use `mix phx.gen.release` to generate a `bin/server`
# script that automatically sets the env var above.
if env!("PHX_SERVER", :boolean!) do
  config :<%= @app_name %>, <%= @endpoint_module %>, server: true
end

# Initialize plugs at runtime for faster development compilation
# values can be :runtime or :compile; must be :compile in prod (the default)
config :phoenix, :plug_init_mode, env!("PHX_PLUGIN_INIT_MODE", :existing_atom!)

# Use Jason for JSON parsing in Phoenix
config :phoenix, :json_library, Jason

ip =
  env!("HTTP_INTERFACE", fn val ->
    with [_] <- String.split(val, "."),
         [_] <- String.split(val, ":") do
      raise "Invalid IP address specified"
    else
      parts -> parts |> Enum.map(&String.to_integer/1) |> List.to_tuple()
    end
  end)

ecto_socket_options = if env!("ECTO_IPV6", :boolean!), do: [:inet6], else: []

config :<%= @app_name %>, <%= @app_module %>.Repo,
  # ssl: true,
  url: env!("DATABASE_URL", :string!),
  pool: env!("PG_POOL", :module?),
  pool_size: env!("POOL_SIZE", :integer!),
  socket_options: ecto_socket_options,
  stacktrace: env!("ECTO_STACKTRACE", :boolean),
  show_sensitive_data_on_connection_error:
    env!("SHOW_SENSITIVE_DATA_ON_CONNECTION_ERROR", :boolean)

if env!("ENABLE_DISTRIBUTED_MODE", :boolean) do
  config :<%= @app_name %>, :dns_cluster_query, env!("DNS_CLUSTER_QUERY", :string)
end

config :<%= @app_name %>, <%= @endpoint_module %>,
  cache_static_manifest: env!("PHX_CACHE_STATIC_MANIFEST", :string?),
  check_origin: env!("HTTP_CHECK_ORIGIN", :boolean),
  http: [ip: ip, port: env!("PORT", :integer!)],
  secret_key_base: env!("SECRET_KEY_BASE", :string!),
  # Used to build URLs
  url: [
    host: env!("PHX_HOST", :string!),
    port: env!("PHX_URL_PORT", :integer!),
    scheme: env!("PHX_URL_SCHEME", :string!)
  ]

# ## SSL Support
#
# To get SSL working, you will need to add the `https` key
# to your endpoint configuration:
#
#     config :<%= @app_name %>, <%= @endpoint_module %>,
#       https: [
#         ...,
#         port: 443,
#         cipher_suite: :strong,
#         keyfile: System.get_env("SOME_APP_SSL_KEY_PATH"),
#         certfile: System.get_env("SOME_APP_SSL_CERT_PATH")
#       ]
#
# The `cipher_suite` is set to `:strong` to support only the
# latest and more secure SSL ciphers. This means old browsers
# and clients may not be supported. You can set it to
# `:compatible` for wider support.
#
# `:keyfile` and `:certfile` expect an absolute path to the key
# and cert in disk or a relative path inside priv, for example
# "priv/ssl/server.key". For all supported SSL configuration
# options, see https://hexdocs.pm/plug/Plug.SSL.html#configure/1
#
# We also recommend setting `force_ssl` in your config/prod.exs,
# ensuring no data is ever sent via http, always redirecting to https:
#
#     config :<%= @app_name %>, <%= @endpoint_module %>,
#       force_ssl: [hsts: true]
#
# Check `Plug.SSL` for all available options in `force_ssl`.
#
# In order to use HTTPS in development, a self-signed
# certificate can be generated by running the following
# Mix task:
#
#     mix phx.gen.cert
#
# Run `mix help phx.gen.cert` for more information.
#
# The `http:` config above can be replaced with:
#
#     https: [
#       port: 4001,
#       cipher_suite: :strong,
#       keyfile: "priv/cert/selfsigned_key.pem",
#       certfile: "priv/cert/selfsigned.pem"
#     ],
#
# If desired, both `http:` and `https:` keys can be
# configured to run both http and https servers on
# different ports.

# ## Configuring the mailer
#
# In production you need to configure the mailer to use a different adapter.
# Also, you may need to configure the Swoosh API client of your choice if you
# are not using SMTP. Here is an example of the configuration:
#
#     config :src_me, SrcMe.Mailer,
#       adapter: Swoosh.Adapters.Mailgun,
#       api_key: System.get_env("MAILGUN_API_KEY"),
#       domain: System.get_env("MAILGUN_DOMAIN")
#
# For this example you need include a HTTP client required by Swoosh API client.
# Swoosh supports Hackney and Finch out of the box:
#
#     config :swoosh, :api_client, Swoosh.ApiClient.Hackney
#
# See https://hexdocs.pm/swoosh/Swoosh.html#module-installation for details.
# Configures Swoosh API Client
if env!("SWOOSH_API_CLIENT", :boolean) do
  config :swoosh, api_client: env!("SWOOSH_API_CLIENT", :module!), finch_name: SrcMe.Finch
else
  config :swoosh, api_client: false
end

config :<%= @app_name %>, <%= @app_module %>.Mailer, adapter: env!("SWOOSH_MAILER_ADAPTER", :module)
config :swoosh, api_client: Swoosh.ApiClient.Finch, finch_name: SrcMe.Finch
config :swoosh, local: env!("SWOOSH_LOCAL_MEMORY_STORAGE", :boolean)
